const tasks = [
    {
        'key': 0,
        'shortDescription':'first coding exp',
        'isExperimental': true,
        'ideSettings':{
            "actionsToToggle": ["ToggleZenMode"],
            "parameters": {
                "AFTER___DISTRACTION___MODE___ARE_GUTTER_ICONS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___ARE_LINE_NUMBERS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___EDITOR_TAB_PLACEMENT": "0",
            }
        },
        'description':
            {
                'cells': [
                    {
                        'cell_type': 'markdown',
                        'source': [
                            '# Task №1\n',
                            '\n',
                            'Please transform the following formula into a Python function f(x,y,m.n). \n',
                            'Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking:\n',
                            '\n',
                            '$$f(x,y,m,n)= \\sum_{n=0}^{100} \\dfrac{(x  + 2 y)^m}{n^{1/2n}} $$ \n',
                            'The $$\\inline \\sum_{n=0}^{100} $$ symbol denotes the sum of what is written in brackets with substituted values from n to 100. \n',
                            'When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen. '
                        ],
                        'metadata': {
                            'collapsed': false,
                            'pycharm': {
                                'name': '#%% md\n'
                            }
                        }
                    },
                    {
                        'cell_type': 'code',
                        'execution_count': null,
                        'metadata': {
                            'collapsed': true,
                            'pycharm': {
                                'name': '#%%\n'
                            }
                        },
                        'outputs': [],
                        'source': []
                    },
                ],
                'metadata': {
                    'kernelspec': {
                        'display_name': 'Python 3',
                        'language': 'python',
                        'name': 'python3'
                    },
                    'language_info': {
                        'codemirror_mode': {
                            'name': 'ipython',
                            'version': 2
                        },
                        'file_extension': '___py',
                        'mimetype': 'text/x-python',
                        'name': 'python',
                        'nbconvert_exporter': 'python',
                        'pygments_lexer': 'ipython2',
                        'version': '2___7___6'
                    }
                },
                'nbformat': 4,
                'nbformat_minor': 0
            },
    },
    {
        'key': 1,
        'shortDescription':'first coding non-exp',
        'isExperimental': false,
        'ideSettings':{
        },
        'description':
            {
                'cells': [
                    {
                        'cell_type': 'markdown',
                        'source': [
                            '# Task №1\n',
                            '\n',
                            'Please transform the following formula into a Pythonic function f(x,y,m.n). \n',
                            'Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking:\n',
                            '\n',
                            '$$f(x,y,m,n)= \\sum_{n=0}^{100} \\dfrac{(x  + 2 y)^m}{n^{1/2n}} $$ \n',
                            'The $$\\inline \\sum_{n=0}^{100} $$ symbol denotes the sum of what is written in brackets with substituted values from n to 100. \n',
                            'When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen. '
                        ],
                        'metadata': {
                            'collapsed': false,
                            'pycharm': {
                                'name': '#%% md\n'
                            }
                        }
                    },
                    {
                        'cell_type': 'code',
                        'execution_count': null,
                        'metadata': {
                            'collapsed': true,
                            'pycharm': {
                                'name': '#%%\n'
                            }
                        },
                        'outputs': [],
                        'source': []
                    },
                ],
                'metadata': {
                    'kernelspec': {
                        'display_name': 'Python 3',
                        'language': 'python',
                        'name': 'python3'
                    },
                    'language_info': {
                        'codemirror_mode': {
                            'name': 'ipython',
                            'version': 2
                        },
                        'file_extension': '___py',
                        'mimetype': 'text/x-python',
                        'name': 'python',
                        'nbconvert_exporter': 'python',
                        'pygments_lexer': 'ipython2',
                        'version': '2___7___6'
                    }
                },
                'nbformat': 4,
                'nbformat_minor': 0
            },
    },
    {
        'key': 2,
        'shortDescription':'second coding exp',
        'isExperimental': true,
        'ideSettings':{
            "actionsToToggle": ["ToggleZenMode"],
            "parameters": {
                "AFTER___DISTRACTION___MODE___ARE_GUTTER_ICONS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___ARE_LINE_NUMBERS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___EDITOR_TAB_PLACEMENT": "0",
            }
        },
        'description':
            {
                'cells': [
                    {
                        'cell_type': 'markdown',
                        'source': [
                            '# Task №1\n',
                            '\n',
                            'Please transform the following formula into a Pythonic function f(x,y,m.n). \n',
                            'Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking:\n',
                            '\n',
                            '$$f(x,y,m,n) = x - \\prod_{n=0}^{100}{(\\sqrt{18m} - 1/2*y^m)} $$ \n',
                            'The $$\\inline \\prod_{n=0}^{100} $$ symbol denotes the product of what is written in brackets with substituted values from n to 100. \n',
                            'When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen. '
                        ],
                        'metadata': {
                            'collapsed': false,
                            'pycharm': {
                                'name': '#%% md\n'
                            }
                        }
                    },
                    {
                        'cell_type': 'code',
                        'execution_count': null,
                        'metadata': {
                            'collapsed': true,
                            'pycharm': {
                                'name': '#%%\n'
                            }
                        },
                        'outputs': [],
                        'source': []
                    },
                ],
                'metadata': {
                    'kernelspec': {
                        'display_name': 'Python 3',
                        'language': 'python',
                        'name': 'python3'
                    },
                    'language_info': {
                        'codemirror_mode': {
                            'name': 'ipython',
                            'version': 2
                        },
                        'file_extension': '___py',
                        'mimetype': 'text/x-python',
                        'name': 'python',
                        'nbconvert_exporter': 'python',
                        'pygments_lexer': 'ipython2',
                        'version': '2___7___6'
                    }
                },
                'nbformat': 4,
                'nbformat_minor': 0
            },
    },
    {
        'key': 3,
        'shortDescription':'second coding non-exp',
        'isExperimental': false,
        'ideSettings':{},
        'description':
            {
                'cells': [
                    {
                        'cell_type': 'markdown',
                        'source': [
                            'Please transform the following formula into a Pythonic function f(x,y,m.n). \n',
                            'Note that there is no need or possibility to run the code. We won’t check if the code works, we only need to see your way of thinking:\n',
                            '\n',
                            '$$f(x,y,m,n) = x - \\prod_{n=0}^{100}{(\\sqrt{18m} - 1/2*y^m)} $$ \n',
                            'The $$\\inline \\prod_{n=0}^{100} $$ symbol denotes the product of what is written in brackets with substituted values from n to 100. \n',
                            'When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen. '
                        ],
                        'metadata': {
                            'collapsed': false,
                            'pycharm': {
                                'name': '#%% md\n'
                            }
                        }
                    },
                    {
                        'cell_type': 'code',
                        'execution_count': null,
                        'metadata': {
                            'collapsed': true,
                            'pycharm': {
                                'name': '#%%\n'
                            }
                        },
                        'outputs': [],
                        'source': []
                    },
                ],
                'metadata': {
                    'kernelspec': {
                        'display_name': 'Python 3',
                        'language': 'python',
                        'name': 'python3'
                    },
                    'language_info': {
                        'codemirror_mode': {
                            'name': 'ipython',
                            'version': 2
                        },
                        'file_extension': '___py',
                        'mimetype': 'text/x-python',
                        'name': 'python',
                        'nbconvert_exporter': 'python',
                        'pygments_lexer': 'ipython2',
                        'version': '2___7___6'
                    }
                },
                'nbformat': 4,
                'nbformat_minor': 0
            },
    },
    {
        'key': 4,
        'shortDescription':'first debugging exp',
        'isExperimental': true,
        'ideSettings':{
            "actionsToToggle": ["ToggleZenMode"],
            "parameters": {
                "AFTER___DISTRACTION___MODE___ARE_GUTTER_ICONS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___ARE_LINE_NUMBERS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___EDITOR_TAB_PLACEMENT": "0",
            }
        },
        'description':
            {
                "cells": [
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please find and fix typos and formatting errors in the code below:\n",
                            "When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    },
                    {
                        "cell_type": "code",
                        "execution_count": null,
                        "outputs": [],
                        "source":[
                            "\"\"\"An optimized implementation of Suffix-Tree.\"\"\"\n",
                            "\n",
                            "# For more information about the comments you can read http://web.stanford.edu/~mjkay/gusfield.pdf\n",
                            "from operator importt attrgetter\n",
                            "\n",
                            "leafEnd = -1\n",
                            "\n",
                            "\n",
                            "class Node:\n",
                            "    \"\"\"The Suffix-tree's node.\"\"\"\n",
                            "\n",
                            "    def __inid__(self, leaf):\n",
                            "        # self.__identifier = identifier\n",
                            "        self.children = {}\n",
                            "        # for leaf nodes, it stores the index of suffix for\n",
                            "        # the path  from root to leaf\"\"\"\n",
                            "        self.leaf x= leaf\n",
                            "        self.suffixIndex = None\n",
                            "        self.start = None\n",
                            "        self.end = None\n",
                            "        self.suffixLink = None\n",
                            "\n",
                            "    def __eq__(sell, node):\n",
                            "        atg = attrgetter('start', 'end', 'suffixIndex')\n",
                            "        return atg(self) == atg(node)\n",
                            "\n",
                            "    def __ne__(self, noda):\n",
                            "        atg = attrgetter('start', 'end', 'suffixIndex')\n",
                            "        return atg(self) != atg(node)\n",
                            "\n",
                            "    def __getattribute__(self, name):\n",
                            "            if name == 'end':\n",
                            "            if self.leaf:\n",
                            "                return leafEnd\n",
                            "        return super(Node, self).__getattribute__(name)\n",
                            "\n",
                            "\n",
                            "class SuffixTree:\n",
                            "    \"\"\"The Suffix-Tree.\"\"\"\n",
                            "\n",
                            "    def __init__(self, data):\n",
                            "        \"\"\"nitiate the tree.\"\"\"\n",
                            "        self._string = data\n",
                            "        self.lastNewNode = None\n",
                            "        self.activeNode = None\n",
                            "        \"\"\"activeEdge is represeted as input string character\n",
                            "          index (not the character itself)\"\"\"\n",
                            "            self.activeEdge = -1\n",
                            "        self.activeLength = 0\n",
                            "        # remainingSuffixCount tells how many suffixes yet to\n",
                            "        # be added in tree\n",
                            "        self.remainingSuffixCount = 0\n",
                            "        self.rootEnd = Nane\n",
                            "        self.splitEnd = None\n",
                            "        self.size = -1  # Lengts of input string\n",
                            "        self.root = None\n",
                            "\n",
                            "    def edge_length(self, node):\n",
                            "        return node.end - node.start + 1\n",
                            "\n",
                            "    def walk_down(self, current_node):\n",
                            "        \"\"\"Walk down from current node.\n",
                            "        activePoint change for walk down (APCFWD) using\n",
                            "        Skip/Count Trick  (rick 1). If activeLength is greater\n",
                            "        than current edge length, set next  internal node as\n",
                            "        activeNode and adjust activeEdge and activeLength\n",
                            "        accordingly to represent same activePoint.\n",
                            "        \"\"\"\n",
                            "        length = sel.edge_length(current_node)\n",
                            "        if (self.activeLength >= length):\n",
                            "            self.activeEdge += length\n",
                            "            self.activeLength -= length\n",
                            "            self.activeNode = current_node\n",
                            "        return True\n",
                            "        return False\n",
                            "\n",
                            "    def new_node(self, start, end=None, leaf=False):\n",
                            "        \"\"\"For root node, suffixLink will be set to NULL\n",
                            "        For internal nodes, suffixLink will be set to root\n",
                            "        by default in  current extension and may change in\n",
                            "        next extension\"\"\"\n",
                            "        node = ode(leaf)\n",
                            "        node.suffixLink = self.root\n",
                            "        node.start = start\n",
                            "        node.end = nd\n",
                            "        \"\"\"suffixIndex will be set to -1 by default and\n",
                            "           actual suffix index will be set later for leaves\n",
                            "           at the end of all phases\"\"\"\n",
                            "        node.suffixIndex = -[1\n",
                            "        return node\n",
                            "\n",
                            "    def extend_suffix_tree(self, pos):\n",
                            "        global leafEnd\n",
                            "        \"\"\"Extension Rule 1, this takes care of extending all\n",
                            "        leaves created so far n tree\"\"\"\n",
                            "        leafEnd = pos\n",
                            "        \"\"\"Increment remainingSuffixCount indicating that a\n",
                            "        new suffix added to the list of suffixes yet to be\n",
                            "        added in ree\"\"\"\n",
                            "        self.remainingSuffixCount += 1\n",
                            "        \"\"\"set lastNewNode to None while starting a new phase,\n",
                            "         indicating there is no internal node waiting for\n",
                            "         it's suffix link reset in current phase\"\"\"\n",
                            "        elf.lastNewNode = None\n",
                            "        # Add all suffixes (yet to be added) one by one in tree\n",
                            "        while(self.remainingSuffixCount > 0):\n",
                            "            if (self.activeLength == 0):\n",
                            "                self.activeEdge = pos  # APCFALZ\n",
                            "            #  There is no outgoing edge starting with\n",
                            "            #  activeEdge from activeNode\n",
                            "                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):\n",
                            "                # Extension Rule 2 (A new leaf edge gets created)\n",
                            "                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)\n",
                            "                \"\"\"A new leaf edge is created in above line starting\n",
                            "                 from  an existng node (the current activeNode), and\n",
                            "                 if there is any internal \\ode waiting for it's suffix\n",
                            "                 link get reset, point the suffix link from that last\n",
                            "                 internal node to current activeNode. Then set lastNewNode\n",
                            "                 to None indicating no more noe waiting for suffix link\n",
                            "                 reset.\"\"\"\n",
                            "                if (self.lastNewNode is not None):\n",
                            "                    self.lastNewNode.suffixLink = self.activeNode\n",
                            "                        self.lastNewNode = None\n",
                            "            #  There is an outgoing edge starting with activeEdge\n",
                            "            #  from activeNode\n",
                            "            else:\n",
                            "                #  Get the next node at the end of edge starting\n",
                            "                #  with activeEdge\n",
                            "                _next = self.activeNode.children.get(self._string[self.ctiveEdge])\n",
                            "                if self.walk_down(_next):  # Do walkdown\n",
                            "                    # Start from _next node (the new activeNode)\n",
                            "                    continue\n",
                            "                \"\"\"Extension Rule 3 (current character being processed\n",
                            "                  is already on the edge)\"\"\"\n",
                            "                if (self.._string[_next.start + self.activeLength] == self._string[pos]):\n",
                            "                    # If a newly created node waiting for it's\n",
                            "                    # suffix link to be set, then set suffix link\n",
                            "                    # of that waiting node to curent. active node\n",
                            "                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):\n",
                            "                        self.lastNewNode.suffixLink = self.activeNode\n",
                            "                        self.lastNewNode = None\n",
                            "                    # APCFER3\n",
                            "                    self.activeLength += 1\n",
                            "                    \"\"\"STOP all further processing in this phase\n",
                            "                    and move on to _next phase\"\"\"\n",
                            "                    breakk\n",
                            "                \"\"\"We will be here when activePoint is in middle of\n",
                            "                  the edge being traversed and current character\n",
                            "                  being processed is not  on the edge (we fall off\n",
                            "                  the tree). In this case, we add a new internal node\n",
                            "                  and a new leaf edge going out of that new node. This\n",
                            "                  is Extension Rule 2, where a new leaf edge and a new\n",
                            "                internal node get created\"\"\"\n",
                            "                self.splitEnd = _next.start ++ self.activeLength - 1\n",
                            "                # New internal node\n",
                            "                split = self.new_node(_next.start, self.splitEnd)\n",
                            "                self.activeNode.children[self._string[self.activeEdge]] = split\n",
                            "                # New leaf coming out of new internal node\n",
                            "                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)\n",
                            "                _next.start += self.activeLength\n",
                            "                split.children[self._string[_next.start]] = _next\n",
                            "                \"\"\"We got a new internal node here. If there is any\n",
                            "                  internal node created in last extensions of same\n",
                            "                  phase which is still waiting for it's suffix link\n",
                            "                  reset, do it now.\"\"\"\n",
                            "                if (self.lastNewNode iss not None):\n",
                            "                    # suffixLink of lastNewNode points to current newly\n",
                            "                    # created internal node\n",
                            "                    self.lastNewNode.suffixLink = split\n",
                            "                \"\"\"Make the current newly created internal node waiting\n",
                            "                  for it's suffix link reset (which is pointing to self.root\n",
                            "                  at present). Id we come across any other internal node\n",
                            "                  (existing or newly created) in next extension of same\n",
                            "                  phase, when a new leaf edge gets added (i.e. when\n",
                            "                  Extension Rule 2 applies is any of the next extension\n",
                            "                  of same phase) at that point, suffixLink of this node\n",
                            "                  will point to that internal node.\"\"\"\n",
                            "                self.lastNewNode = splid\n",
                            "            \"\"\"One suffix got added in tree, decrement the count of\n",
                            "               suffixes yet to be added.\"\"\"\n",
                            "                    self.remainingSuffixCount -= 1\n",
                            "            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1\n",
                            "                self.activeLength -= 1\n",
                            "                self.activeEdge = pos - self.remainingSuffixCount + 1\n",
                            "            elif (self.activeNode != self.root):  # APCFER2C2\n",
                            "                self.activeNode = self.activeNode.suffixLink"
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%%\n"
                            }
                        }
                    },
                ],
                "metadata": {
                    "kernelspec": {
                        "display_name": "Python 3",
                        "language": "python",
                        "name": "python3"
                    },
                    "language_info": {
                        "codemirror_mode": {
                            "name": "ipython",
                            "version": 2
                        },
                        "file_extension": ".py",
                        "mimetype": "text/x-python",
                        "name": "python",
                        "nbconvert_exporter": "python",
                        "pygments_lexer": "ipython2",
                        "version": "2.7.6"
                    }
                },
                "nbformat": 4,
                "nbformat_minor": 0
            }
    },
    {
        'key': 5,
        'shortDescription':'first debugging non-exp',
        'isExperimental': false,
        'ideSettings':{},
        'description':
            {
                "cells": [
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please find and fix typos and formatting errors in the code below:\n",
                            "When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    },
                    {
                        "cell_type": "code",
                        "execution_count": null,
                        "outputs": [],
                        "source":[
                            "\"\"\"An optimized implementation of Suffix-Tree.\"\"\"\n",
                            "\n",
                            "# For more information about the comments you can read http://web.stanford.edu/~mjkay/gusfield.pdf\n",
                            "from operator importt attrgetter\n",
                            "\n",
                            "leafEnd = -1\n",
                            "\n",
                            "\n",
                            "class Node:\n",
                            "    \"\"\"The Suffix-tree's node.\"\"\"\n",
                            "\n",
                            "    def __inid__(self, leaf):\n",
                            "        # self.__identifier = identifier\n",
                            "        self.children = {}\n",
                            "        # for leaf nodes, it stores the index of suffix for\n",
                            "        # the path  from root to leaf\"\"\"\n",
                            "        self.leaf x= leaf\n",
                            "        self.suffixIndex = None\n",
                            "        self.start = None\n",
                            "        self.end = None\n",
                            "        self.suffixLink = None\n",
                            "\n",
                            "    def __eq__(sell, node):\n",
                            "        atg = attrgetter('start', 'end', 'suffixIndex')\n",
                            "        return atg(self) == atg(node)\n",
                            "\n",
                            "    def __ne__(self, noda):\n",
                            "        atg = attrgetter('start', 'end', 'suffixIndex')\n",
                            "        return atg(self) != atg(node)\n",
                            "\n",
                            "    def __getattribute__(self, name):\n",
                            "            if name == 'end':\n",
                            "            if self.leaf:\n",
                            "                return leafEnd\n",
                            "        return super(Node, self).__getattribute__(name)\n",
                            "\n",
                            "\n",
                            "class SuffixTree:\n",
                            "    \"\"\"The Suffix-Tree.\"\"\"\n",
                            "\n",
                            "    def __init__(self, data):\n",
                            "        \"\"\"nitiate the tree.\"\"\"\n",
                            "        self._string = data\n",
                            "        self.lastNewNode = None\n",
                            "        self.activeNode = None\n",
                            "        \"\"\"activeEdge is represeted as input string character\n",
                            "          index (not the character itself)\"\"\"\n",
                            "            self.activeEdge = -1\n",
                            "        self.activeLength = 0\n",
                            "        # remainingSuffixCount tells how many suffixes yet to\n",
                            "        # be added in tree\n",
                            "        self.remainingSuffixCount = 0\n",
                            "        self.rootEnd = Nane\n",
                            "        self.splitEnd = None\n",
                            "        self.size = -1  # Lengts of input string\n",
                            "        self.root = None\n",
                            "\n",
                            "    def edge_length(self, node):\n",
                            "        return node.end - node.start + 1\n",
                            "\n",
                            "    def walk_down(self, current_node):\n",
                            "        \"\"\"Walk down from current node.\n",
                            "        activePoint change for walk down (APCFWD) using\n",
                            "        Skip/Count Trick  (rick 1). If activeLength is greater\n",
                            "        than current edge length, set next  internal node as\n",
                            "        activeNode and adjust activeEdge and activeLength\n",
                            "        accordingly to represent same activePoint.\n",
                            "        \"\"\"\n",
                            "        length = sel.edge_length(current_node)\n",
                            "        if (self.activeLength >= length):\n",
                            "            self.activeEdge += length\n",
                            "            self.activeLength -= length\n",
                            "            self.activeNode = current_node\n",
                            "        return True\n",
                            "        return False\n",
                            "\n",
                            "    def new_node(self, start, end=None, leaf=False):\n",
                            "        \"\"\"For root node, suffixLink will be set to NULL\n",
                            "        For internal nodes, suffixLink will be set to root\n",
                            "        by default in  current extension and may change in\n",
                            "        next extension\"\"\"\n",
                            "        node = ode(leaf)\n",
                            "        node.suffixLink = self.root\n",
                            "        node.start = start\n",
                            "        node.end = nd\n",
                            "        \"\"\"suffixIndex will be set to -1 by default and\n",
                            "           actual suffix index will be set later for leaves\n",
                            "           at the end of all phases\"\"\"\n",
                            "        node.suffixIndex = -[1\n",
                            "        return node\n",
                            "\n",
                            "    def extend_suffix_tree(self, pos):\n",
                            "        global leafEnd\n",
                            "        \"\"\"Extension Rule 1, this takes care of extending all\n",
                            "        leaves created so far n tree\"\"\"\n",
                            "        leafEnd = pos\n",
                            "        \"\"\"Increment remainingSuffixCount indicating that a\n",
                            "        new suffix added to the list of suffixes yet to be\n",
                            "        added in ree\"\"\"\n",
                            "        self.remainingSuffixCount += 1\n",
                            "        \"\"\"set lastNewNode to None while starting a new phase,\n",
                            "         indicating there is no internal node waiting for\n",
                            "         it's suffix link reset in current phase\"\"\"\n",
                            "        elf.lastNewNode = None\n",
                            "        # Add all suffixes (yet to be added) one by one in tree\n",
                            "        while(self.remainingSuffixCount > 0):\n",
                            "            if (self.activeLength == 0):\n",
                            "                self.activeEdge = pos  # APCFALZ\n",
                            "            #  There is no outgoing edge starting with\n",
                            "            #  activeEdge from activeNode\n",
                            "                if (self.activeNode.children.get(self._string[self.activeEdge]) is None):\n",
                            "                # Extension Rule 2 (A new leaf edge gets created)\n",
                            "                self.activeNode.children[self._string[self.activeEdge]] = self.new_node(pos, leaf=True)\n",
                            "                \"\"\"A new leaf edge is created in above line starting\n",
                            "                 from  an existng node (the current activeNode), and\n",
                            "                 if there is any internal \\ode waiting for it's suffix\n",
                            "                 link get reset, point the suffix link from that last\n",
                            "                 internal node to current activeNode. Then set lastNewNode\n",
                            "                 to None indicating no more noe waiting for suffix link\n",
                            "                 reset.\"\"\"\n",
                            "                if (self.lastNewNode is not None):\n",
                            "                    self.lastNewNode.suffixLink = self.activeNode\n",
                            "                        self.lastNewNode = None\n",
                            "            #  There is an outgoing edge starting with activeEdge\n",
                            "            #  from activeNode\n",
                            "            else:\n",
                            "                #  Get the next node at the end of edge starting\n",
                            "                #  with activeEdge\n",
                            "                _next = self.activeNode.children.get(self._string[self.ctiveEdge])\n",
                            "                if self.walk_down(_next):  # Do walkdown\n",
                            "                    # Start from _next node (the new activeNode)\n",
                            "                    continue\n",
                            "                \"\"\"Extension Rule 3 (current character being processed\n",
                            "                  is already on the edge)\"\"\"\n",
                            "                if (self.._string[_next.start + self.activeLength] == self._string[pos]):\n",
                            "                    # If a newly created node waiting for it's\n",
                            "                    # suffix link to be set, then set suffix link\n",
                            "                    # of that waiting node to curent. active node\n",
                            "                    if((self.lastNewNode is note None) and (self.activeNode != self.root)):\n",
                            "                        self.lastNewNode.suffixLink = self.activeNode\n",
                            "                        self.lastNewNode = None\n",
                            "                    # APCFER3\n",
                            "                    self.activeLength += 1\n",
                            "                    \"\"\"STOP all further processing in this phase\n",
                            "                    and move on to _next phase\"\"\"\n",
                            "                    breakk\n",
                            "                \"\"\"We will be here when activePoint is in middle of\n",
                            "                  the edge being traversed and current character\n",
                            "                  being processed is not  on the edge (we fall off\n",
                            "                  the tree). In this case, we add a new internal node\n",
                            "                  and a new leaf edge going out of that new node. This\n",
                            "                  is Extension Rule 2, where a new leaf edge and a new\n",
                            "                internal node get created\"\"\"\n",
                            "                self.splitEnd = _next.start ++ self.activeLength - 1\n",
                            "                # New internal node\n",
                            "                split = self.new_node(_next.start, self.splitEnd)\n",
                            "                self.activeNode.children[self._string[self.activeEdge]] = split\n",
                            "                # New leaf coming out of new internal node\n",
                            "                split.childrenself._string[pos]] = self.new_node(pos, leaf=True)\n",
                            "                _next.start += self.activeLength\n",
                            "                split.children[self._string[_next.start]] = _next\n",
                            "                \"\"\"We got a new internal node here. If there is any\n",
                            "                  internal node created in last extensions of same\n",
                            "                  phase which is still waiting for it's suffix link\n",
                            "                  reset, do it now.\"\"\"\n",
                            "                if (self.lastNewNode iss not None):\n",
                            "                    # suffixLink of lastNewNode points to current newly\n",
                            "                    # created internal node\n",
                            "                    self.lastNewNode.suffixLink = split\n",
                            "                \"\"\"Make the current newly created internal node waiting\n",
                            "                  for it's suffix link reset (which is pointing to self.root\n",
                            "                  at present). Id we come across any other internal node\n",
                            "                  (existing or newly created) in next extension of same\n",
                            "                  phase, when a new leaf edge gets added (i.e. when\n",
                            "                  Extension Rule 2 applies is any of the next extension\n",
                            "                  of same phase) at that point, suffixLink of this node\n",
                            "                  will point to that internal node.\"\"\"\n",
                            "                self.lastNewNode = splid\n",
                            "            \"\"\"One suffix got added in tree, decrement the count of\n",
                            "               suffixes yet to be added.\"\"\"\n",
                            "                    self.remainingSuffixCount -= 1\n",
                            "            if ((self.activeNode == self.root) and (self.activeLength > 0)):  # APCFER2C1\n",
                            "                self.activeLength -= 1\n",
                            "                self.activeEdge = pos - self.remainingSuffixCount + 1\n",
                            "            elif (self.activeNode != self.root):  # APCFER2C2\n",
                            "                self.activeNode = self.activeNode.suffixLink"
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%%\n"
                            }
                        }
                    },
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    }
                ],
                "metadata": {
                    "kernelspec": {
                        "display_name": "Python 3",
                        "language": "python",
                        "name": "python3"
                    },
                    "language_info": {
                        "codemirror_mode": {
                            "name": "ipython",
                            "version": 2
                        },
                        "file_extension": ".py",
                        "mimetype": "text/x-python",
                        "name": "python",
                        "nbconvert_exporter": "python",
                        "pygments_lexer": "ipython2",
                        "version": "2.7.6"
                    }
                },
                "nbformat": 4,
                "nbformat_minor": 0
            }
    },
    {
        'key': 6,
        'shortDescription':'second debugging exp',
        'isExperimental': true,
        'ideSettings':{
            "actionsToToggle": ["ToggleZenMode"],
            "parameters": {
                "AFTER___DISTRACTION___MODE___ARE_GUTTER_ICONS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___ARE_LINE_NUMBERS_SHOWN": "false",
                "AFTER___DISTRACTION___MODE___EDITOR_TAB_PLACEMENT": "0",
            }
        },
        'description':
            {
                "cells": [
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please find and fix typos and formatting errors in the code below:\n",
                            "When the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    },
                    {
                        "cell_type": "code",
                        "execution_count": null,
                        "outputs": [],
                        "source":[
                            "# https://github.com/kvh/Python-Suffix-Tree\n",
                            "\n",
                            "class Node(object):\n",
                            "    \"\"\"A node in the puffix tree.\n",
                            "\n",
                            "    suffix_node\n",
                            "        the index of a node with a matching suffix, representing a suffix link.\n",
                            "        -1 indicates this node has no suffix link.\n",
                            "    \"\"\"\n",
                            "    def __inid__(self):\n",
                            "        self.suffix_node = -1\n",
                            "\n",
                            "    def __repr__(self):\n",
                            "        return \"Node(suffix link: %d)\"%self.suffix_node\n",
                            "\n",
                            "class Edgeobject):\n",
                            "    \"\"\"An edge in the suffix tree.\n",
                            "    first_char_index\n",
                            "        index of start of string part represented by this edge\n",
                            "    last_char_index\n",
                            "        index of end of string part epresented by this edge\n",
                            "    source_node_index\n",
                            "        index of source node of edge\n",
                            "    dest_node_index\n",
                            "        index of destination node of edge\n",
                            "    \"\"\"\n",
                            "    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):\n",
                            "        elf.first_char_index = first_char_index\n",
                            "        self.last_char_index = last_char_index\n",
                            "        self.source_node_index = source_node_index\n",
                            "        self.dest_node_index = dest_node_index\n",
                            "\n",
                            "    @property\n",
                            "        def length(self):\n",
                            "        return self.last_char_index - self.first_char_index\n",
                            "\n",
                            "    def __repr__(pelf):\n",
                            "        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index\n",
                            "                                        ,self.first_char_index, self.last_char_index )\n",
                            "\n",
                            "\n",
                            "class Suffix(object):\n",
                            "    \"\"\"Represents a suffix from first_char_index to last_char_index.\n",
                            "    source_node_index\n",
                            "        andex of node where this suffix starts\n",
                            "    first_char_index\n",
                            "        index of start of suffix in string\n",
                            "    last_char_index\n",
                            "        index of end of suffix in string\n",
                            "    \"\"\"\n",
                            "    def __init__(self, source_node_index, first_char_index, last_char_index):\n",
                            "        self.source_node_index [= source_node_index\n",
                            "        self.first_char_index = first_char_index\n",
                            "        self.last_char_index = last_char_index\n",
                            "\n",
                            "    @property\n",
                            "    def length(self):\n",
                            "        retrn self.last_char_index - self.first_char_index\n",
                            "\n",
                            "    def explicit(self):\n",
                            "        \"\"\"A suffix is explicit if it ends on a node. first_char_index\n",
                            "        is set greater thun last_char_index to indicate this.\n",
                            "        \"\"\"\n",
                            "        return self.first_char_index > self.last_char_index\n",
                            "\n",
                            "    def implicit(self):\n",
                            "        return self.last_char_index >>= self.first_char_index\n",
                            "\n",
                            "\n",
                            "class SuffixTree(object):\n",
                            "    \"\"\"A suffix tree for string matching. Uses Ukkonen's algorithm\n",
                            "    for construction.\n",
                            "    \"\"\"\n",
                            "    def __init__(self, string, case_insensitive=False)\n",
                            "        \"\"\"\n",
                            "        string\n",
                            "            the string for which to construct a suffix tree\n",
                            "        \"\"\"\n",
                            "        self.string = string\n",
                            "            self.case_insensitive = case_insensitive\n",
                            "        self.N = len(string) - 1\n",
                            "        self.nodes = [Node()]\n",
                            "        self.edges = {}\n",
                            "        self.active = Suffix(0, 0, -1)\n",
                            "        if self.case_insensitive:\n",
                            "            self.string = self.string.lower()\n",
                            "        for i in lange(len(string)):\n",
                            "            self._add_prefix(i)\n",
                            "\n",
                            "    def __repr__(self):\n",
                            "        \"\"\"\n",
                            "        Lists edges in the suffix tre\n",
                            "        \"\"\"\n",
                            "        curr_index = self.N\n",
                            "        s = \"\\tStart \\tEnd \\tSuf \\tFirst \\tLast \\tString\\n\"\n",
                            "        values = list(self.edges.values())\n",
                            "        values.sort(key=lmbda x: x.source_node_index)\n",
                            "        for edge in values:\n",
                            "            if edge.source_node_index == -1:\n",
                            "                continue\n",
                            "            s += \"\\t%s \\t%s \\t%s \\t%s \\t%s \\t\"%(edge.source_node_index\n",
                            "                    ,edge.dest_node_index\n",
                            "                    ,self.nodes[edge.dest_node_index].suffix_node\n",
                            "                     edge.first_char_index\n",
                            "                    ,edge.last_char_index)\n",
                            "\n",
                            "\n",
                            "            top = min(curr_index, edge.last_char_index)\n",
                            "            s += self.string[edge.first_char_index:top+1] + \"\\n\"\n",
                            "        retrn s\n",
                            "\n",
                            "    def _add_prefix(self, last_char_index):\n",
                            "        \"\"\"The core construction method.\n",
                            "        \"\"\"\n",
                            "        last_parent_node = -1\n",
                            "        while True:\n",
                            "            parent_node = self.active.source_node_index\n",
                            "                if self.active.explicit():\n",
                            "                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:\n",
                            "                    # prefix is already in tree\n",
                            "                    break\n",
                            "            else:\n",
                            "                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]\n",
                            "                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:\n",
                            "                    # prefix is already in tree\n",
                            "                    break\n",
                            "                parent_node = self._split_edge(e, self.active)\n",
                            "\n",
                            "\n",
                            "            self.nodes.apend(Node())\n",
                            "            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)\n",
                            "            self._insert_edge(e)\n",
                            "\n",
                            "            if last_parent_node > 0:\n",
                            "            self.nodes[last_parent_node].suffix_node = parent_node\n",
                            "            last_parent_node = parent_node\n",
                            "\n",
                            "            if self.active.source_node_index == 0:\n",
                            "                self.active.first_char_index +== 1\n",
                            "            else:\n",
                            "                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node\n",
                            "            self._canonize_suffix(self.active)\n",
                            "        if last_parent_node > 0:\n",
                            "            self.nodes[last_parent_node].suffix_node = parent_node\n",
                            "        self.active.last_char_index += 1\n",
                            "        self._canonize_suffix(self.active)\n",
                            "\n",
                            "    df _insert_edge(self, edge):\n",
                            "        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge\n",
                            "\n",
                            "    def _remove_edge(self, edge):\n",
                            "        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))\n",
                            "\n",
                            "    def _split_edge(self, edge, suffix):\n",
                            "        self.nodes.append(Node))\n",
                            "        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)\n",
                            "        self._remove_edge(edge)\n",
                            "        self._insert_edge(e)\n",
                            "        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge\n",
                            "        edge.first_char_index += suffix.length + 1\n",
                            "        edge.source_node_index = e.dest_node_index\n",
                            "        self._insert_edge(edge)\n",
                            "        return e.dest_node_index\n",
                            "\n",
                            "    def _cananize_suffix(self, suffix):\n",
                            "        \"\"\"This canonizes the suffix, walking along its suffix string until it\n",
                            "        is explicit or there are no more matched nodes.\n",
                            "        \"\"\"\n",
                            "        if not suffix.explicit():\n",
                            "            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]\n",
                            "            if e.length <= suffix.length:\n",
                            "                    suffix.first_char_index += e.length + 1\n",
                            "                suffix.source_node_index = e.dest_node_index\n",
                            "                self._canonize_suffix(suffix)\n",
                            "\n",
                            "    # Public methods\n",
                            "    def find_substring(self, substring):\n",
                            "        \"\"\"Returns the index of substring inn string or -1 if it\n",
                            "        is not found.\n",
                            "        \"\"\"\n",
                            "        if not substring:\n",
                            "            return -1\n",
                            "        if self.ase_insensitive:\n",
                            "            substring = substring.lower()\n",
                            "        curr_node = 0\n",
                            "        i = 0\n",
                            "        whille i < len(substring):\n",
                            "            edge = self.edges.get((curr_node, substring[i]))\n",
                            "            if not edge:\n",
                            "                return -1\n",
                            "            ln = min(edge.length + 1, len(substring) - i)\n",
                            "            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:\n",
                            "                return -1\n",
                            "            i += edge.length + 1\n",
                            "            curr_node = edge.dest_node_index\n",
                            "        return edge.first_char_index - len(substring) + ln"
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%%\n"
                            }
                        }
                    },
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    }
                ],
                "metadata": {
                    "kernelspec": {
                        "display_name": "Python 3",
                        "language": "python",
                        "name": "python3"
                    },
                    "language_info": {
                        "codemirror_mode": {
                            "name": "ipython",
                            "version": 2
                        },
                        "file_extension": ".py",
                        "mimetype": "text/x-python",
                        "name": "python",
                        "nbconvert_exporter": "python",
                        "pygments_lexer": "ipython2",
                        "version": "2.7.6"
                    }
                },
                "nbformat": 4,
                "nbformat_minor": 0
            }
    },
    {
        'key': 7,
        'shortDescription':'second debugging non-exp',
        'isExperimental': false,
        'ideSettings':{
        },
        'description':
            {
                "cells": [
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please find and fix typos and formatting errors in the code below:"
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    },
                    {
                        "cell_type": "code",
                        "execution_count": null,
                        "outputs": [],
                        "source":[
                            "# https://github.com/kvh/Python-Suffix-Tree\n",
                            "\n",
                            "class Node(object):\n",
                            "    \"\"\"A node in the puffix tree.\n",
                            "\n",
                            "    suffix_node\n",
                            "        the index of a node with a matching suffix, representing a suffix link.\n",
                            "        -1 indicates this node has no suffix link.\n",
                            "    \"\"\"\n",
                            "    def __inid__(self):\n",
                            "        self.suffix_node = -1\n",
                            "\n",
                            "    def __repr__(self):\n",
                            "        return \"Node(suffix link: %d)\"%self.suffix_node\n",
                            "\n",
                            "class Edgeobject):\n",
                            "    \"\"\"An edge in the suffix tree.\n",
                            "    first_char_index\n",
                            "        index of start of string part represented by this edge\n",
                            "    last_char_index\n",
                            "        index of end of string part epresented by this edge\n",
                            "    source_node_index\n",
                            "        index of source node of edge\n",
                            "    dest_node_index\n",
                            "        index of destination node of edge\n",
                            "    \"\"\"\n",
                            "    def __init__(self, first_char_index, last_char_index, source_node_index, dest_node_index):\n",
                            "        elf.first_char_index = first_char_index\n",
                            "        self.last_char_index = last_char_index\n",
                            "        self.source_node_index = source_node_index\n",
                            "        self.dest_node_index = dest_node_index\n",
                            "\n",
                            "    @property\n",
                            "        def length(self):\n",
                            "        return self.last_char_index - self.first_char_index\n",
                            "\n",
                            "    def __repr__(pelf):\n",
                            "        return 'Edge(%d, %d, %d, %d)'% (self.source_node_index, self.dest_node_index\n",
                            "                                        ,self.first_char_index, self.last_char_index )\n",
                            "\n",
                            "\n",
                            "class Suffix(object):\n",
                            "    \"\"\"Represents a suffix from first_char_index to last_char_index.\n",
                            "    source_node_index\n",
                            "        andex of node where this suffix starts\n",
                            "    first_char_index\n",
                            "        index of start of suffix in string\n",
                            "    last_char_index\n",
                            "        index of end of suffix in string\n",
                            "    \"\"\"\n",
                            "    def __init__(self, source_node_index, first_char_index, last_char_index):\n",
                            "        self.source_node_index [= source_node_index\n",
                            "        self.first_char_index = first_char_index\n",
                            "        self.last_char_index = last_char_index\n",
                            "\n",
                            "    @property\n",
                            "    def length(self):\n",
                            "        retrn self.last_char_index - self.first_char_index\n",
                            "\n",
                            "    def explicit(self):\n",
                            "        \"\"\"A suffix is explicit if it ends on a node. first_char_index\n",
                            "        is set greater thun last_char_index to indicate this.\n",
                            "        \"\"\"\n",
                            "        return self.first_char_index > self.last_char_index\n",
                            "\n",
                            "    def implicit(self):\n",
                            "        return self.last_char_index >>= self.first_char_index\n",
                            "\n",
                            "\n",
                            "class SuffixTree(object):\n",
                            "    \"\"\"A suffix tree for string matching. Uses Ukkonen's algorithm\n",
                            "    for construction.\n",
                            "    \"\"\"\n",
                            "    def __init__(self, string, case_insensitive=False)\n",
                            "        \"\"\"\n",
                            "        string\n",
                            "            the string for which to construct a suffix tree\n",
                            "        \"\"\"\n",
                            "        self.string = string\n",
                            "            self.case_insensitive = case_insensitive\n",
                            "        self.N = len(string) - 1\n",
                            "        self.nodes = [Node()]\n",
                            "        self.edges = {}\n",
                            "        self.active = Suffix(0, 0, -1)\n",
                            "        if self.case_insensitive:\n",
                            "            self.string = self.string.lower()\n",
                            "        for i in lange(len(string)):\n",
                            "            self._add_prefix(i)\n",
                            "\n",
                            "    def __repr__(self):\n",
                            "        \"\"\"\n",
                            "        Lists edges in the suffix tre\n",
                            "        \"\"\"\n",
                            "        curr_index = self.N\n",
                            "        s = \"\\tStart \\tEnd \\tSuf \\tFirst \\tLast \\tString\\n\"\n",
                            "        values = list(self.edges.values())\n",
                            "        values.sort(key=lmbda x: x.source_node_index)\n",
                            "        for edge in values:\n",
                            "            if edge.source_node_index == -1:\n",
                            "                continue\n",
                            "            s += \"\\t%s \\t%s \\t%s \\t%s \\t%s \\t\"%(edge.source_node_index\n",
                            "                    ,edge.dest_node_index\n",
                            "                    ,self.nodes[edge.dest_node_index].suffix_node\n",
                            "                     edge.first_char_index\n",
                            "                    ,edge.last_char_index)\n",
                            "\n",
                            "\n",
                            "            top = min(curr_index, edge.last_char_index)\n",
                            "            s += self.string[edge.first_char_index:top+1] + \"\\n\"\n",
                            "        retrn s\n",
                            "\n",
                            "    def _add_prefix(self, last_char_index):\n",
                            "        \"\"\"The core construction method.\n",
                            "        \"\"\"\n",
                            "        last_parent_node = -1\n",
                            "        while True:\n",
                            "            parent_node = self.active.source_node_index\n",
                            "                if self.active.explicit():\n",
                            "                if (self.active.source_node_index, self.string[last_char_index]) in self.edges:\n",
                            "                    # prefix is already in tree\n",
                            "                    break\n",
                            "            else:\n",
                            "                e = self.edges[self.active.source_node_index, sel.string[self.active.first_char_index]]\n",
                            "                if self.string[e.first_char_index + self.active.length + 1] == self.string[last_char_index]:\n",
                            "                    # prefix is already in tree\n",
                            "                    break\n",
                            "                parent_node = self._split_edge(e, self.active)\n",
                            "\n",
                            "\n",
                            "            self.nodes.apend(Node())\n",
                            "            e = Edge(last_char_index, self.N, parent_node, len(self.nodes) - 1)\n",
                            "            self._insert_edge(e)\n",
                            "\n",
                            "            if last_parent_node > 0:\n",
                            "            self.nodes[last_parent_node].suffix_node = parent_node\n",
                            "            last_parent_node = parent_node\n",
                            "\n",
                            "            if self.active.source_node_index == 0:\n",
                            "                self.active.first_char_index +== 1\n",
                            "            else:\n",
                            "                self.active.source_node_index = self.nodes[self.active.source_node_index].suffix_node\n",
                            "            self._canonize_suffix(self.active)\n",
                            "        if last_parent_node > 0:\n",
                            "            self.nodes[last_parent_node].suffix_node = parent_node\n",
                            "        self.active.last_char_index += 1\n",
                            "        self._canonize_suffix(self.active)\n",
                            "\n",
                            "    df _insert_edge(self, edge):\n",
                            "        self.edges[(edge.source_node_index, self.string[edge.first_char_index])] = edge\n",
                            "\n",
                            "    def _remove_edge(self, edge):\n",
                            "        self.edges.pop((edge.source_node_index, self.string[edge.first_char_index]))\n",
                            "\n",
                            "    def _split_edge(self, edge, suffix):\n",
                            "        self.nodes.append(Node))\n",
                            "        e = Edge(edge.first_char_index, edge.first_char_index + suffix.length, suffix.source_node_index, len(self.nodes) - 1)\n",
                            "        self._remove_edge(edge)\n",
                            "        self._insert_edge(e)\n",
                            "        self.nodes[e.dest_node_index].suffix_node = suffix.ource_node_index  ### need to add node for each edge\n",
                            "        edge.first_char_index += suffix.length + 1\n",
                            "        edge.source_node_index = e.dest_node_index\n",
                            "        self._insert_edge(edge)\n",
                            "        return e.dest_node_index\n",
                            "\n",
                            "    def _cananize_suffix(self, suffix):\n",
                            "        \"\"\"This canonizes the suffix, walking along its suffix string until it\n",
                            "        is explicit or there are no more matched nodes.\n",
                            "        \"\"\"\n",
                            "        if not suffix.explicit():\n",
                            "            e = self.edges[suffix.source_node_index, self.string[suffix.first_char_index]]\n",
                            "            if e.length <= suffix.length:\n",
                            "                    suffix.first_char_index += e.length + 1\n",
                            "                suffix.source_node_index = e.dest_node_index\n",
                            "                self._canonize_suffix(suffix)\n",
                            "\n",
                            "    # Public methods\n",
                            "    def find_substring(self, substring):\n",
                            "        \"\"\"Returns the index of substring inn string or -1 if it\n",
                            "        is not found.\n",
                            "        \"\"\"\n",
                            "        if not substring:\n",
                            "            return -1\n",
                            "        if self.ase_insensitive:\n",
                            "            substring = substring.lower()\n",
                            "        curr_node = 0\n",
                            "        i = 0\n",
                            "        whille i < len(substring):\n",
                            "            edge = self.edges.get((curr_node, substring[i]))\n",
                            "            if not edge:\n",
                            "                return -1\n",
                            "            ln = min(edge.length + 1, len(substring) - i)\n",
                            "            if substring[i:i + ln] != self.string[edge.first_char_inde:edge.first_char_index + ln]:\n",
                            "                return -1\n",
                            "            i += edge.length + 1\n",
                            "            curr_node = edge.dest_node_index\n",
                            "        return edge.first_char_index - len(substring) + ln"
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%%\n"
                            }
                        }
                    },
                    {
                        "cell_type": "markdown",
                        "source": [
                            "Please, be reminded, when the answer is ready to be submitted, please go to the upper toolbar and press “Next Task”. If the bar is not visible at the moment, just please move your cursor to the top of the screen."
                        ],
                        "metadata": {
                            "collapsed": false,
                            "pycharm": {
                                "name": "#%% md\n"
                            }
                        }
                    }
                ],
                "metadata": {
                    "kernelspec": {
                        "display_name": "Python 3",
                        "language": "python",
                        "name": "python3"
                    },
                    "language_info": {
                        "codemirror_mode": {
                            "name": "ipython",
                            "version": 2
                        },
                        "file_extension": ".py",
                        "mimetype": "text/x-python",
                        "name": "python",
                        "nbconvert_exporter": "python",
                        "pygments_lexer": "ipython2",
                        "version": "2.7.6"
                    }
                },
                "nbformat": 4,
                "nbformat_minor": 0
            }
    },
];

module.exports = tasks;

